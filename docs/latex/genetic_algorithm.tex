% The flow chart created here depicts PyVVO's load modeling procedures.
\documentclass[tikz]{standalone}

% Load up the basic commands.
\input{flow_base}

\begin{document}
\begin{tikzpicture}[flowchart, node distance=1.2cm] 
\tikzstyle{every node}=[font=\large]

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% NODES AND ARROWS
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{pgfonlayer}{main}
	\node (start)
	[startstop]
	{Start.};
	% Create a coordinate which will be referenced for all labels.
	\coordinate (start-east) at ($(start.east) + (1.5,0)$);
	\path ($(start-east)$); \pgfgetlastxy{\XLabel}{\YCoord};
	% Label our first node.
	\LabelNode{start}
	%
	\node (init-ga)
	[process, below=of start, yshift=-2.0cm]
	{Initialize a \code{GA} object. Inputs include dictionaries of equipment objects (with up-to-date states)
	and times related to GridLAB-D simulation start/stop.};
	\LabelNode{init-ga}
	%
	\draw[arrows.meta] (start) -- (init-ga);
	%
	\node (start-ga)
	[process, below=of init-ga]
	{Start the genetic algorithm in a thread by calling \code{GA.run()}. This way, the algorithm can be interrupted
	if necessary (\textit{e.g.}, if system topology changes). The sole input to this method is a \code{GLMManager}
	whose model contains an up-to-date representation of the system.};
	\LabelNode{start-ga}
	%
	\draw[arrows.meta] (init-ga) -- (start-ga);
	%
	\node (map-chrom)
	[process, below=of start-ga, yshift=-2.0cm]
	{Initialize and map the chromosome, which takes the form of one large list of 0's and 1's (binary). Each regulator
	phase is represented as a binary number ranging from 0 (lowest tap) to the highest tap (\textit{e.g.}, 32).
	The location of these phase tap representations within the phase chromosome is mapped. Capacitor phases
	are simply 0 or 1 (open or closed) and are similarly mapped.};
	\LabelNode{map-chrom}
	%
	\draw[arrows.meta] (start-ga) -- (map-chrom);
	%
	\node (prep-glm)
	[process, below=of map-chrom]
	{Prepare the \code{GLMManager}'s model to be run. The model must be augmented with standard GridLAB-D
	obejcts and directives (\textit{e.g.}, clock object, powerflow module), MySQL database information (\textit{e.g.}, host
	and user), and recorder objects to pipe model outputs to the MySQL database. Additionally, regulators and capacitors
	must be put in MANUAL control mode.};
	\LabelNode{prep-glm}
	%
	\draw[arrows.meta] (map-chrom) -- (prep-glm);
	%
	\node (init-pop-obj)
	[process, below=of prep-glm]
	{Initialize queues for parallel processing, track configuration parameters, start processes to be used for evaluating
	the fitness of \code{Individual}s.};
	\LabelNode{init-pop-obj}
	%
	\draw[arrows.meta] (prep-glm) -- (init-pop-obj);
	%
	\node (init-ind)
	[process, below=of init-pop-obj, yshift=-2.0cm]
	{Initialize an individual and place it in the population. Initialization includes random (or defined) chromosome 
	generation. The chromosomes are generated by drawing a random valid state for each equipment phase,
	converting the state to its binary representation, and using the chromosome map from \acref{flow:map-chrom}
	to appropriately position the binary representation.};
	\LabelNode{init-ind}
	%
	\draw[arrows.meta] (init-pop-obj) -- (init-ind);
	%
	\node (pop-full)
	[decision, below=of init-ind, label={[yshift=+0.5cm] left:no}, label={[xshift=+0.5cm] below:yes}]
	{Population full?};
	\LabelNode{pop-full}
	%
	\draw[arrows.meta] (init-ind) -- (pop-full);
	%
	\node (extract-ind)
	[process, below=of pop-full, yshift=-2.0cm]
	{Extract an individual from the population.};
	% Manually create the label so it can be shifted.
	\node (extract-ind-label) at ($(start-east |- extract-ind.east) + (0.0cm,0.3cm)$) {\ac{flow:extract-ind}};
	%
	\draw[arrows.meta] (pop-full) -- (extract-ind);
	%
	\draw[arrows.meta] (pop-full.west) -| ++(-4.0cm,0cm) |- (init-ind);
	% Create a coordinate out past this arrow.
	\coordinate (pop-full-west) at ($(pop-full.west) + (-5.0cm,0.0cm)$);
	% Mirror it. Gross hard-coding.
	\coordinate (pop-full-east) at ($(pop-full.east) + (+5.0cm,0.0cm)$);
	
	%
	\node (update-glm)
	[process, below=of extract-ind]
	{Using a copy of the \code{GLMManager} from \acref{flow:prep-glm}, update equipment states in the model
	based on this \code{Individual}'s chromosome. Update database table names based on this \code{Individual}'s
	UID.};
	\LabelNode{update-glm}
	%
	\draw[arrows.meta] (extract-ind) -- (update-glm);
	%
	\node (truncate-tables)
	[process, below=of update-glm]
	{Purge tables referenced in \acref{flow:update-glm} of data, if they exist.};
	\LabelNode{truncate-tables}
	%
	\draw[arrows.meta] (update-glm) -- (truncate-tables);
	%
	\node (run-glm)
	[process, below=of truncate-tables]
	{Write .glm model to file and run it. Data related to head-of-feeder measurements and meter measurements
	are piped to MySQL database into the tables identified in \acref{flow:update-glm}.};
	\LabelNode{run-glm}
	%
	\draw[arrows.meta] (truncate-tables) -- (run-glm);
	%
	\node (pull-run-data)
	[io, below=of run-glm]
	{Extract data from MySQL database related to the model run in \acref{flow:run-glm}. This process is made 
	more efficient by using intelligent MySQL queries, \textit{e.g.}, only pulling voltage data above or below the
	voltage thresholds.};
	\LabelNode{pull-run-data}
	%
	\draw[arrows.meta] (run-glm) -- (pull-run-data);
	%
	\node (compute-fitness)
	[process, below=of pull-run-data]
	{Using data from \acref{flow:pull-run-data}, evaluate this \code{Individual}'s fitness. The objective function 
	combines costs related to energy consumption, head-of-feeder power factor, and customer voltage 
	violations.};
	\LabelNode{compute-fitness}
	%
	\draw[arrows.meta] (pull-run-data) -- (compute-fitness);
	%
	\node (all-evaluated)
	[decision, below=of compute-fitness, label={[yshift=+0.5cm] left:no}, label={[xshift=+0.5cm] below:yes}]
	{All \code{Individual}s evaluated?};
	\LabelNode{all-evaluated}
	%
	\draw[arrows.meta] (compute-fitness) -- (all-evaluated);
	%
	\node (maybe-done)
	[decision, below=of all-evaluated, yshift=-0.75cm, label={[xshift=+0.5cm] below:no}, label={[yshift=+0.5cm] right:yes}]
	{Done?};
	% Need to put this label in a custom location so it doesn't get run over by the arrow.
	\node (maybe-done-label) at ($(maybe-done.east -| start-east) + (0,-0.3)$) {\ac{flow:stop}};
	%
	\draw[arrows.meta] (all-evaluated) -- (maybe-done);
	%
	\node (stop)
	[startstop, left=of maybe-done]
	{Return best \code{Individual} from the population.};
	% Label to the right, like the LabelNode command does.
	% TODO: add more functions to stop this gross hard-coding.
	\node (stop-label) at ($(stop.west) - (1.5,0)$) {\ac{flow:stop}};
	%
	\draw[arrows.meta] (maybe-done) -- (stop);
	%
	\node (elitism)
	[process, below=of maybe-done, yshift=-2.0cm]
	{Sort the population by fitness (lower value is better), and identify a prescribed percentage of the
	population which will be kept (this process is known as ``elitism'').};
	\LabelNode{elitism}
	% 
	\draw[arrows.meta] (maybe-done) -- (elitism);
	%
	\node (tournament)
	[process, below=of elitism]
	{Randomly select a prescribed number of individuals that did not make the cut in \acref{flow:elitism}.
	The best individual from this random selection will be kept (this process is known as a ``tournament'').};
	\LabelNode{tournament}
	%
	\draw[arrows.meta] (elitism) -- (tournament);
	%
	\node (all-selected)
	[decision, below=of tournament, label={[yshift=+0.5cm] left:no}, label={[xshift=+0.5cm] below:yes}]
	{Has the prescribed total number of \code{Individual}s to keep been met?};
	\LabelNode{all-selected}
	%
	\draw[arrows.meta] (tournament) -- (all-selected);
	%
	\node (two-parents)
	[process, below=of all-selected, yshift=-2.0cm]
	{Similar to \acref{flow:tournament}, select two ``parents'' from the pool of individuals that have been
	kept via a tournament.};
	\LabelNode{two-parents}
	%
	\draw[arrows.meta] (all-selected) -- (two-parents);
	%
	\draw[arrows.meta] (all-selected.west) -| ++(-3.0cm,0.0cm) |- (tournament);
	%
	\node (maybe-crossover)
	[decision, below=of two-parents, label={[yshift=+0.5cm] left:yes}, label={[yshift=+0.5cm] right:no}]
	{Perform crossover?};
	\LabelNode{maybe-crossover}
	%
	\draw[arrows.meta] (two-parents) -- (maybe-crossover);
	%
	% TODO: This positioning is not great and hard-coded.
	\node (crossover)
	[process, below=of maybe-crossover.west, xshift=-3.2cm, yshift=-2.5cm]
	{Create two offspring by performing crossover with the given parents. For each section of the chromosome
	that represents a piece of equipment (a ``gene''), randomly decide which parent to pull chromosome data
	for.};
	% Label the node. This is performed similarly to the LabelNode command.
	\node (crossover-label) at ($(crossover.west) - (1.5,0)$) {\ac{flow:crossover}};
	%
	\draw[arrows.meta] (maybe-crossover.west) -| (crossover);
	%
	\node (mutate-children)
	[process, below=of crossover]
	{(Possibly) mutate each child. Mutation is as described in \acref{flow:asex-rep}.};
	% Label.
	\node (mutate-children-label) at ($(mutate-children.west) - (1.5, 0)$) {\ac{flow:mutate-children}};
	% 
	\draw[arrows.meta] (crossover) -- (mutate-children);
	%
	\node (asex-rep)
	[process, right=of crossover]
	{Create two offspring. Child one is a mutated version of parent one, likewise for child two and parent two. 
	Mutation is performed by randomly flipping bits in the chromosome.};
	% Label the node, again similarly to LabelNode.
	\node (asex-rep-label) at ($(asex-rep.east) + (1.5,0)$) {\ac{flow:asex-rep}};
	%
	\draw[arrows.meta] (maybe-crossover.east) -| (asex-rep);
	%
	% Create a dummy node to get us back on track.
	\node (dummy)
	[process, draw=none, fill=none, below=of mutate-children]
	{};
	%
	\node (children-in-pop) at (dummy -| maybe-crossover)
	[process]
	{Add the resulting two children to the population.};
	\LabelNode{children-in-pop}
	%
	\draw[arrows.meta] (asex-rep) |- (children-in-pop);
	%
	\draw[arrows.meta] (mutate-children) |- (children-in-pop);
	%
	\node (pop-full-2)
	[decision, below=of children-in-pop, label={[yshift=+0.5cm] left:no}, label={[yshift=+0.5cm] right:yes}]
	{Population full?};
	% Manually create the label so it can be shifted.
	\node (pop-full-2-label) at ($(start-east |- pop-full-2.east) + (0.0cm,0.3cm)$) {\ac{flow:pop-full-2}};
	%
	\draw[arrows.meta] (children-in-pop) -- (pop-full-2);
	%
	\draw[arrows.meta] (pop-full-2.west) -| ++(-11.0cm,0.0cm) |- (two-parents);
	%
	\draw [arrows.meta] (pop-full-2.east) -| ++ (+11.0cm,0.0cm) |- (extract-ind);
	% coordinates.
	\coordinate (pop-full-2-east) at ($(pop-full-2.east) + (-17.0cm, 0.0cm)$);
	\coordinate (pop-full-2-west) at ($(pop-full-2.west) + (+17.0cm, 0.0cm)$);
	\end{pgfonlayer}
	
	% Background layer.
	\begin{pgfonlayer}{background}
		% GA object
		% Place a coordinate above init-ga
		\coordinate(above-init-ga) at ($(init-ga.north) + (0.0cm, 1.0cm)$);
		\node (app-ga)
		[backgroundbox, draw=cyan, fill=cyan!20, fit = (above-init-ga) (init-ga) (start-ga) (init-ga -| pop-full-west) (init-ga -| pop-full-east)]
		{};
		\node (app-ga-label)
		[text width=4.0cm, xshift=+2.5cm, yshift=-1.0cm, cyan, fill=white]
		at (app-ga.north west) {\textbf{Init. and start; see app.py.}};
		
		% Population object
		% Place a coordinate above map-chrom
		\coordinate(above-map-chrom) at ($(map-chrom.north) + (0.0cm, 1.0cm)$);
		\node (init-pop-obj-background)
		[backgroundbox, draw=red, fill=red!20, fit = (above-map-chrom) (init-pop-obj)
		(init-pop-obj.west -| pop-full-west) (init-pop-obj.east -| pop-full-east)]
		{};
		\node (init-pop-obj-label)
		[text width=4.0cm, xshift=+2.5cm, yshift=-1.0cm, red, fill=white]
		at (init-pop-obj-background.north west) {\textbf{Instantiate a \code{Population} object.}};
		
		% Initialize individuals in population
		% Place coordinate above init-ind
		\coordinate(above-init-ind) at ($(init-ind.north) + (0.0cm, 1.0cm)$);
		\node (init-pop)
		[backgroundbox, draw=blue, fill=blue!20, fit = (above-init-ind) (init-ind) (pop-full)
		(pop-full-west) (pop-full-east)]
		{};
		\node (init-pip-label)
		[text width=4.0cm, xshift=2.5cm, yshift=-1.0cm, blue, fill=white]
		at (init-pop.north west) {\textbf{Initialize the population}};
		
		% Evaluate individuals in population
		\coordinate(above-extract-ind) at ($(extract-ind.north) + (0.0cm, 1.0cm)$);
		\node (eval-pop)
		[backgroundbox, draw=teal, fill=teal!20, fit = (above-extract-ind) (extract-ind)
		(all-evaluated) (pull-run-data) (extract-ind.west -| pop-full-west) (extract-ind.east -| pop-full-east)]
		{};
		\node (eval-pop-label)
		[text width=4.0cm, xshift=2.5cm, yshift=-1.0cm, teal, fill=white]
		at (eval-pop.north west) {\textbf{Evaluate the population}};
		
		% Natural selection
		\coordinate(above-elitism) at ($(elitism.north) + (0.0cm, 1.0cm)$);
		\node (nat-select)
		[backgroundbox, draw=violet, fill=violet!20, fit = (above-elitism) (elitism) (all-selected)
		(elitism.west -| pop-full-west) (elitism.east -| pop-full-east)]
		{};
		\node (nat-select-label)
		[text width=4.0cm, xshift=2.5cm, yshift=-1.0cm, violet, fill=white]
		at (nat-select.north west) {\textbf{Perform natural selection}};
		
		% Crossover and mutation
		\coordinate(above-two-parents) at ($(two-parents.north) + (0.0cm, 1.0cm)$);
		\node (cross-mut)
		[backgroundbox, draw=magenta, fill=magenta!20, fit = (above-two-parents) (pop-full-2)
		(pop-full-2-east) (pop-full-2-west)]
		{};
		\node (cross-mut-label)
		[text width=4.0cm, xshift=2.5cm, yshift=-1.0cm, magenta, fill=white]
		at (cross-mut.north west -| nat-select.north west)
		{\textbf{Crossover and Mutation}};
	\end{pgfonlayer}
\end{tikzpicture}
\end{document}